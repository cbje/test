<!doctype html>
<html>
<head>
<meta charset="utf-8">
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<style>	
body{
	background-image: 
	linear-gradient(white 1px,transparent 0),
	linear-gradient(90deg,white 1px,transparent 0);
	background-size: 30px 30px;
	padding: 0px;
	margin: 0px;
}
</style>
</head>
<body >
<div id="app">

</div> 
<canvas id=myCanvas></canvas>
<script>
	var canvas = document.getElementById('myCanvas'),
ctx = canvas.getContext('2d'),
image = new Image();

image.onload = function() {
  Promise.all([
    createImageBitmap(this, 0, 0, 32, 32),
    createImageBitmap(this, 32, 0, 32, 32)
  ]).then(function(sprites) {
    ctx.drawImage(sprites[0], 0, 0);
    ctx.drawImage(sprites[1], 32, 32);
  });
}

image.src = '5.jpg';
	// window.onload=function(){
// 	var http=new XMLHttpRequest();
// 	http.open("get","AA.asp");
// 	http.responseType="blob";
// 	http.onload=function(){
// 		var read=new FileReader();
// 		read.addEventListener("load",function(){
// 			var img=document.createElement("img");
// 			img.src=read.result;
// 			img.style.width="180px";
// 			img.style.height="180px";
// 			document.body.appendChild(img);
// 		});
// 		read.readAsDataURL(http.response);
// 	}
// 	http.send("null")
// }
	 function loadimg(a){
	 	var xhr=new XMLHttpRequest();
	 	xhr.open("get","aa.asp?img="+a+".jpg");
	 	xhr.responseType="blob";
	 	xhr.onreadystatechange=function(){
	 		if(xhr.readyState===4 && xhr.status===200){
	 			var read=new FileReader();
					read.addEventListener("load",function(){
				var img=document.createElement("img");
 					img.src=read.result;
 				var div=document.getElementById("app");
 				div.appendChild(img);
 					w.next(a+1);
 					});
 				read.readAsDataURL(xhr.response);
	 		}
	 	}
	 	xhr.send()
	 }
    function *img(){
    	let img;
    	let img1=loadimg(yield img);
    	let img2=loadimg(yield img1);
    	let img3=loadimg(yield img2);
    	let img4=loadimg(yield img3);
    }
var w=img();
w.next();


	// var ele=document.querySelector("#dp");
	// console.log(getComputedStyle(ele).getPropertyValue("height"))

</script>
<!--
	1.js中有那些数据类型.
	2.异步编程：回var someString = new String("hi");          // need to construct a String object explicitly to avoid auto-boxing

someString[Symbol.iterator] = function() {
  return { // this is the iterator object, returning a single element, the string "bye"
    next: function() {
      if (this._first) {
        this._first = false;
        return { value: "bye", done: false };
      } else {
        return { done: true };
      }
    },
    _first: true
  };
};
someString + ""; 调，promises,observables,generator,async-wait的区别。
	3.使用js代理实现简单的数据绑定。
	4.js的并发模型。
	5.new关键字在js中有什么作用.
	6.js中不同的函数调用模式.函数调用，方法调用，.call,.apply
	7.js中iterator和iterable是什么？js中有哪些内置的iterator.
	8.js的对象序列化成Json时，Symbol()类型的值会发生什么？
	9.类型数组Type arrays与传统数组的差别.
	10.js默认参数的原理.
	11.有js引擎支持尾部调用优化的吗。2018年时，没有。
	12.解释单项数据绑定和双向数据绑定。
	13.什么是静态类型？
	14.TypeScript，Flow,Elm，ReasonML,PureScript之间有什么区别？它们的优缺点是什么？
	15.静态类型语言和强类型语言之间有什么区别？在这方面js的本质是什么？
	16.你知道有那些语言是弱类型但静态类型的吗？你知道有哪些语言是动态类型但强类型的吗？
	17.执行上下文，尤其是词法作用域和闭包.
	18.绑定call,bind,apply和this
	19.对象原型，构造函数和mixin
	20.组合和高阶函数
	21.事件委托和冒泡
	22.使用 typeof,instanceof,Object.prototype.toString进行类型转换.
	23.使用document.querySelector选择或查找节点，在旧版浏览器中用document.getElementsByTagName
	24.上下遍历的节点api:Node.parentNode,Node.firstChild,Node.lastChild和Node.childNodes
	25.左右遍历的节点api:Node.previousSibling,Node.nextSibling
	26.Dom操作类：在Dom树中添加，删除，复制，和创建节点。应该如何修改节点的文本内容以及切换，删除和添加css类名等的操作。
	27.css相关：如何安排彼此相邻的两个元素的位置?如何将元素布置成两列或三列？如何根据浏览器宽度大小更改元素的尺寸？自适应设计中如何根据特定断点更改元素的尺寸？css选择器的特异性计算方法？css级联如何影响属性？
	28.css的模块化与命名空间的使用？（https://www.w3cplus.com/css/css-architecture-1.html
	https://www.w3cplus.com/css/css-architecture-2.html)
	29.Html语义标签？（h5相关)
	30.标记属性，例如：disabled,async,defer以及何时使用data-*?
	31.如何使用doctype,以及可以使用哪些元标签？
	32.可访问性问题：如何确保复选框具有更大的响应区域（可以使用标签for,另外还有role="buttom",role="presentation"）等等。
	33.系统设计方面相关知识：MapReduce,分布式键值存储和Cap定理。
	1.)渲染-客户端渲染，服务器端渲染，全局渲染。
	2.)状态管理，是采用单向数据绑定还是双向数据绑定
	3.)异步操作：设计进要考虑是使用XHR或双向调用，如果要兼容旧浏览器是采用隐藏iframe,script标签或XHR.如果不考虑旧版浏览器是使用websocket或是服务器推送事件(sse)EventSource接口Api.
	4.)关注点分离:Model-View-Controller(MVC),Model-View-ViewModel(MVVM),和Model-View-Presenter(MVP)模式的选择。
	5.)多设备支持：你的设计是否同时支持web,移动web,混合应用程序还是每一种场景提供单独的实现。
	34.资产文件交付-在大型应用开发中，独立团队拥有自己的代码库是常有的事。这些代码库可能彼此依赖，那么你的设计如何基于依赖项进行资产文件的构建（代码拆分），测试（单元测试和集成测试）和部署。还需要考虑如何通过CDN交付资产文件或者内联它们来减少网络延迟。
	35.web性能相关:比如将css置于文档的顶部，js脚本位于页面的底部等。
	1.)关键渲染路径。
	2.)Service Worker。
	3.)图像优化。
	4.)延迟加载和捆绑拆分.
	5.)http 2.0和服务器推送的一般含义.
	6.)何时预取和预加载资源。
	7.)减少浏览器回流以及何时将元素提升到GPU。
	8.)浏览器布局，组合和绘制之间的区别.
	36.数据结构与算法：常见的运行时间复杂度算法O(N)和O(NlogN)的。队列，链表，数组，栈的基本操作。
	37.Http请求的相关头信息：get,post的区别，Cache-Control,ETag,Status Codes 和Transfer-Encoding头的应用。
	38.rest与RPC
	39.安全性：何时使用Jsonp,Cor和Iframe.
	40.库应用的相关问题：React/Vue库中组件中写key的作用是什么？
	(对于vue而言)key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度。
	在虚拟dom节点进行交叉对比的时候，当新节点跟旧节点头尾交叉对比没有结果的时候，会根据新节点的key去对比旧节点数组中的key,从而找到相应旧节点（这里对应的是一个key=>index的map映射）。如果没找到就认为是一个新增节点。而如果没有key,那么就会采用一种遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言，map映射更快。
	41.什么是防抖和节流？有什么区别？如何实现？
	1.防抖：触发高频事件后n秒内，函数只会执行一次。如果n秒内高频事件再次被触发，则重新计算时间。
	解决思路：每次触发事件时都取消之前的延时调用方法。
	实现代码：
    function debounce(fn){
		let timeout=null//创建一个标记用来存放定时器的返回值。
		return function(){
			clearTimeout(timeout);//每当用户输入的时候把前一个setTimeout Clear掉
			timeout=setTimeout(()=>{//然后又创建一个新的setTimeout,这样就能保证输入字符后的interval（这个代表的是用户输入的间隔时间，即setTimeout的第二个参数值。）间隔内如果还有字符输入的话，就不会执行fn函数。
				fn.apply(this,arguments);
			},500);
		};
	}
	function sayHi(){
		console.log("防抖成功!")
	}
	var ele=document.getElementByid("inp");
	ele.addEventListener('input',debounce(sayHi));//防抖，注意这是input事件防抖。
	2.节流：高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率。
	解决思路：每次事件触发时都判断当前是否有等待执行的延时函数。
	实现代码：
	function throttle(fn){
	let canrun=true;//通过闭包保存一个标记。
	return function(){
		if(!canrun) return ; //在函数开头判断标记是否为true,不为true则return。
		canrun=false; //立即设置为false
		setTimeout(()=>{//将外部传入的函数的执行放在setTimeout中
			fn.apply(this,arguments);
			//最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false,在开头被return掉
			canrun=true;
		},500);
	};
	}
	function sayHi(e){
	console.log(e.target.innerWidth,e.target.innerHeight);
	}
	window.addEventListener("resize",throttle(sayHi));
	42.介绍下set,map,weakset和weakmap的区别？
	set:
	成员唯一，无序且不重复。
	[value,value],键值与键名是一致的（或者说只有键值，没有键名）;
	可以遍历，方法有:add,delete,has.
	weakset：
	成员都是对象。
	成员都是弱引用，可以被垃圾回收机制回收，可以用来保存dom节点，不容易造成内存泄露。
	不能遍历,方法有add,delete,has.
	map:
	本质上是键值对的集合，类似集合;
	可以遍历，方法很多，可以跟各种数据格式转换。
	weakmap:
	只接受对象为键名(null除外),不接受其他类型的值作为键名;
	键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的;
	不能遍历，方法有get,set,has,delete.
	43.介绍下深度优先遍历和广度优先遍历，如何实现？
	深度优先遍历（DFS）
	深度优先遍历是搜索算法的一种，它沿着树的深度遍历树的节点，尽可能深地搜索树的分支。当节点v的所有边都已被探寻过，将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已探寻源节点到其它所有节点为止，如果还有未被发现的节点，则选择其中一个未被发现的节点为源节点并重复以上操作，直到所有节点都被探寻完成。
	简单的说，dfs就是从图中的一个节点开始追溯，直到最后一个节点，然后回溯，继续追溯下一条路径，直到到达所有的节点，如此往复，直到没有路径为止。
	dfs可以产生相应图的拓扑排序表，利用拓扑排序表可以解决很多问题，例如最大路径问题。一般用堆数据结构来辅助实现dfs算法。
	注意：深度dfs属于盲目搜索，无法保证搜索到的路径为最短路径，也不是在搜索特定的路径，而是通过搜索来查看图中有哪些路么可以选择。
	步骤：
	访问顶点v;
	依次从v的未被访问的邻接点出发，对图进行深度优先遍历;直至图中和v有路径相通的顶点都被访问;
	若此时途中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到所有顶点均被访问过为止。
	实现:
	Graph.prototype.dfs=function(){
		var marked=[];
		for(var i=0;i<this.vertices.length;i++){
			if(!marked[this.vertices[i]]){
				dfsVisit(this.vertices[i])
			}
		}
	}
	function dfsVisit(u){
		let edges=this.edges;
		marked[u]=true;
		console.log(u);
		var neighbors=edges.get(u);
		for(var i=0;i<neighbors.length;i++){
			var w=neighbors[i];
			if(!marked[w]){
			dfsVisit(w);
			}
		}
	}
	44.异步调用的结果：
	async function async1(){
		console.log('async1 start')
		await async2();
		console.log('async1 end')
	}
	async function async2(){
		console.log('async2')
	}
	console.log('script start')
	setTimeout(function(){
	console.log('setTimeout')
	})
	async1()
	new Promise(function(resolve){
		console.log('promise1')
		resolve()
	}).then(function(){
		console.log('promise2')
	})
	console.log('script end ')
	结果为：
	script start
	async1 start
	async2
	promise1
	script end
	async1 end
	promise2
	settimeout
	45.将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组。
	答：Array.from(new Set(arr.flat(Infinity))).sort((a,b)=>{return a-b});
	arr为目标多维数组。
	46.js异步解决方案的发展历程以及优缺点？
	1.回调函数（callback)
	setTimeout(()=>{
	//callback 函数体
	}，1000)
	缺点：回调地狱，不能用try catch捕获错误，不能return
	回调地狱的根本问题在于：
	缺乏顺序性：回调地狱导致的调试困难，和大脑的思维方式不符;
	嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转）;
	嵌套函数过多的话，很难处理错误。
	ajax('xx1',()=>{
		//callback函数体
		ajax('xx2',()=>{
			//callback函数体
			ajax('xx3',()=>{
				//callback函数体
			})
		})
	})
	优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行)
	2.Promise
	Promise就是为了解决callback的问题而产生的。
	Promise实现了链式调用，也就是说每次then后返回的都是一个全新Promise,如果我们在then中return,return的结果会被Promise.resolve()包装.
	优点：解决了回调地狱的问题。
	ajax('xx1')
		.then(res => { 
			//操作逻辑
			return ajax('xx2')
		}).then(res => {
			//操作逻辑
			return ajax('xx3')
		}).then(res => {
			//操作逻辑
		})
	缺点：无法取消Promise,错误需要通过回调函数来捕获。
	3.Generator
	特点：可以控制函数的执行，可以配合co函数库使用。
	function *fetch(){
		yield ajax('xx1',() => {});
		yield ajax('xx2',() => {});
		yield ajax('xx3',() => {});
	}
	let it=fetch();
	let result1=it.next();
	let result2=it.next();
	let result3=it.next();
	4.Async/await
	async,await是异步的终级解决方案。
	优点是:代码清晰，不用像Promise写一大堆then链，处理了回调地狱的问题;
	缺点：await将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用await会导致性能上的降低。
	async function test(){
		//以下代码没有依赖性的放，完全可以使用Promise.all的方式
		//如果有依赖性的话，其实就是解决回调地狱的例子了
	await fetch('xx1');
	await fetch('xx2');
	await fetch('xx3');
	}
	一个使用await的例子:
	let a=0;
	let b=async () => {
	a=a+await 10;
	console.log('2',a)//->'2' 10
	}
	b()
	a++
	console.log('1',a)//-> '1' 1
    以上代码的解释：
    1.首先函数b先执行，在执行到await 10之前变量a 还是0,因为await 内部实现了generator,generator会保留堆栈中的东西，所以这时候a=0被保存了下来;
	2.因为await是异步操作，后来的表达式不返回Promise的话，就会包装成Promise.reslove(返回值),然后会去执行函数外的同步代码;
	3.同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a=0+10.
	上述解释中提到了await内部实现了generator,其它await就是generator加上Promise的语法糖，且内部实现了自动执行generator.如果你熟悉co的话，其实自己就可以实现这样的语法糖。
	47.谈谈你对tcp三次握手和四次挥手的理解
	A代码客户端，B代码服务器端
	[ 三次握手 ]
	(A)-> (B)你好，我是A ;(B)-> (A)收到，我是B;(A)->(B)那么咱们链接了;
	[ 四次挥手 ]
	(A)-> (B)你好，我要关了;(B)-> (A)稍等，还有最后一个包;(B)-> (A)我已经好了，随时关闭;
	(A)-> (B)你关闭吧，不用回复。 [B关闭，A等待2MSL，无回复，关闭] 
	-->
<!-- (function(){
	function $(element){
		this.eles=[];
			for(var i=0,len=element.length;i<len;++i){
			var ele=element[i];
			 if(typeof ele ==="string"){
			 	ele=document.getElementById(ele);
			 }
			 this.eles.push(ele);
		};
	};
	$.prototype.each=function(fn){
		for(var i=0,len=this.eles.length;i<len;++i){
			 fn.call(this,this.eles[i]);
		}
      	return this;
	};
	$.prototype.setstyle=function(sx,zhi){
          this.each(function(ele){
           ele.style[sx]=zhi;
          })
          return this;
	}
	window._$=function(){
		return new $(arguments)
	}
})()
function w(a){
   a.innerText="123";
}
	_$("cc","dd").each(function(ele){
     ele.innerText="red";
	}).setstyle("border","1px solid red"); 


//“模块加载器/模块管理器”
var model=(function manager(){
	var modules={};
	function define(name,deps,impl){
		for(var i=0;i<deps.length;i++){
			deps[i]=modules[deps[i]];
		}
		modules[name]=impl.apply(undefined,deps);
	}
	function get(name){
		return modules[name];
	};
	
	return {
		define:define,
		get:get
	};
})()
model.define("bar",[],function(){
	function hello(who){
		return "Let me introduce:"+who;
	}
	return {
		hello:hello
	};
})
model.define("foo",["bar"],function(){
	var hungry="hippo";
	function awesome(){
		console.log(bar.hello(hungry).toUpperCase());
	}
	return {
		awesome:awesome
	};
})


// window.onload=function(){
// 	var http=new XMLHttpRequest();
// 	http.open("get","AA.asp");
// 	http.responseType="blob";
// 	http.onload=function(){
// 		var read=new FileReader();
// 		read.addEventListener("load",function(){
// 			var img=document.createElement("img");
// 			img.src=read.result;
// 			img.style.width="180px";
// 			img.style.height="180px";
// 			document.body.appendChild(img);
// 		});
// 		read.readAsDataURL(http.response);
// 	}
// 	http.send("null")
// }


// var head=document.getElementById("cbje1");
	// var node=[];
	// function w(html){
	// 	if(html.children.length){
	// 		for(var i=0; i<html.children.length;i++){
	// 			node.push(html.children[i].nodeName);
	// 			w(html.children[i]);
	// 		}
	// 	}else{
	// 		return 
	// 	}
	// }
	// w(head)
	// console.log(node)

	// var ele=document.getElementById("cbje");
	// console.log("childNodes",ele.childNodes);
	// console.log("firstChild",ele.firstChild);
	// console.log("lastChild",ele.lastChild);
	// console.log("parentNode",ele.parentNode);
	// console.log("previousSibling",ele.lastChild.previousSibling);
	// console.log("nextSibling",ele.firstChild.nextSibling);
	// console.log("firstElementChild",ele.firstElementChild);
	// console.log(ele.ownerDocument);
	// console.log(ele.childNodes);
	// console.log(ele.dataset.bf)
// var ele=document.getElementById("dom")
// ele.setAttribute("title","cbje")
// var fmap=new Map()
// fmap.set(function(a,b){return a+b;},4)
// for( w of fmap){
// 	console.log(w[0](2,2)===w[1]?true:false)
// }

// 	window.onload=function(){
// 		var http=new XMLHttpRequest();
// 		http.open("get","AA.asp");
// 		http.responseType="blob";
// 		http.onload = function() {
//   		var reader  = new FileReader();
//   		reader.addEventListener("load", function () {
//     	cbje(reader.result);
//   		}, false); 		
//     	reader.readAsDataURL(http.response); 		
// 		};
// 		http.send(null);
// 	}
// function cbje(w){
// 		var html=document.createElement("img");
// 		html.src=w;
// 		document.body.appendChild(html);
// 	}
-->
</body>
</html>